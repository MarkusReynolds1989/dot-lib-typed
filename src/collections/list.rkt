#lang typed/racket/base/deep

(require "../globals.rkt")
; Returns a new list that contains all pairings of elements from two lists.
#| (: all-pairs (All (T S) (-> (Listof T) (Listof S) (Listof (Pairof T S)))))
(define (all-pairs list-one list-two)
  (if (null? list-one)
      '()
      (append (map (lambda (x) (cons (car list-one) x)) list-two)
              (all-pairs (cdr list-one) list-two)))) |#

; Returns a new list that contains the elements of the first list followed by
; elements of the second list.
(: append (All (T) (-> (Listof T) (Listof T) (Listof T))))
(define (append list-one list-two)
  (if (null? list-one) list-two (cons (car list-one) (append (cdr list-one) list-two))))

; Returns the average of the values in a non-empty list.
(: average (-> (Listof Number) (U Number False)))
(define (average source)
  (if (= 0 (length source)) #f (/ (apply + source) (length source))))

; Returns the average of values in a list generated by applying a function to each
; element of the list.
(: average-by (All (T) (-> (-> T Number) (Listof T) (U Number False))))
(define (average-by projection source)
  (if (= 0 (length source)) #f (average (map projection source))))

; Tests if the list contains the specified element.
(: contains (All (T) (-> T (Listof T) Boolean)))
(define (contains value source)
  (cond
    [(null? source) #f]
    [(equal? (car source) value) #t]
    [else (contains value (cdr source))]))

; Applies a key-generating function to each element of a list and returns a list
; yielding unique keys and their number of occurances in the original list.
; (: count-by (All (T Key) (-> (-> T Key) (Listof T) (Listof (Pairof Key Integer)))))
; (define (count-by projection input)

; Returns an empty list of the given type.
(: empty (All (T) (-> (Listof T))))
(define (empty)
  '())

; Returns the only element of the list.
(: exactly-one (All (T) (-> (Listof T) T)))
(define (exactly-one input)
  (if (= (length input) 1) (car input) (error "Expected a list with exactly one element.")))

; Tests if any element of the list satisifes the given predicate.
(: exists (All (T) (-> (-> T Boolean) (Listof T) Boolean)))
(define (exists predicate input)
  (cond
    [(null? input) #f]
    [(predicate (car input)) #t]
    [else (exists predicate (cdr input))]))

(module+ test
  (require typed/rackunit)

  (test-equal? "Append works." (append '(1 2 3 4) '(1 2 3 4)) '(1 2 3 4 1 2 3 4))

  (test-equal? "Average works." (average '(3 3 3 3 6 6 6 6)) 9/2)

  (test-equal? "Average-by works."
               (average-by (fn ([x : String]) (string-length x)) '("one" "one" "two"))
               3)

  (test-true "Contains returns true." (contains 2 '(1 2 3)))

  (test-false "Contains returns false." (contains "one" '("two" "three" "four")))

  (test-equal? "Empty works." (empty) '())

  (test-eq? "Exactly-one works." (exactly-one '(1)) 1)

  (test-exn "Exactly-one throws." exn:fail? (fn () (exactly-one '(1 2))))

  (test-true "Exists returns true." (exists (fn ([x : Integer]) (= x 1)) '(4 3 2 1)))

  (test-false "Exists returns false."
              (exists (fn ([x : String]) (equal? x "One")) '("two" "three" "four"))))
