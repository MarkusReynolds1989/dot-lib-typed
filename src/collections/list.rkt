#lang typed/racket/base

(require "../globals.rkt"
         (prefix-in Map. "map.rkt")
         threading
         racket/match)

; TODO: This functionality isn't right, we should be able to give lists of different
; lengths.
; Returns a new list that contains all pairings of elements from two lists.
(: all-pairs (All (T S) (-> (Listof T) (Listof S) (Listof (Tuple T S)))))
(define (all-pairs list-one list-two)
  (if (null? list-one)
      '()
      (cons (Tuple (car list-one) (car list-two)) (all-pairs (cdr list-one) (cdr list-two)))))

; Returns a new list that contains the elements of the first list followed by
; elements of the second list.
(: append (All (T) (-> (Listof T) (Listof T) (Listof T))))
(define (append list-one list-two)
  (if (null? list-one) list-two (cons (car list-one) (append (cdr list-one) list-two))))

; Returns the average of the values in a non-empty list.
(: average (-> (Listof Number) Number))
(define (average source)
  (when (= 0 (length source))
    (error "List empty error."))
  (/ (apply + source) (length source)))

; Returns the average of values in a list generated by applying a function to each
; element of the list.
(: average-by (All (T) (-> (-> T Number) (Listof T) Number)))
(define (average-by projection source)
  (when (= 0 (length source))
    (error "List empty error."))
  (average (map projection source)))

; Applies a function to each element in a list and then returns a list of values v where
; the applied function erturns Some(v). Returns an emtpy list when the input list is empty
; or when the applied chooser functionr returns None for all elements.
(: choose (All (T S) (-> (-> T (Maybe S)) (Listof T) (Listof S))))
(define (choose chooser input)
  (cond
    [(null? input) '()]
    [(match (chooser (car input))
       [(Some v) (cons v (choose chooser (cdr input)))])]
    [else (choose chooser (cdr input))]))

; Tests if the list contains the specified element.
(: contains (All (T) (-> T (Listof T) Boolean)))
(define (contains value source)
  (cond
    [(null? source) #f]
    [(equal? (car source) value) #t]
    [else (contains value (cdr source))]))

; Applies a key-generating function to each element of a list and returns a list
; yielding unique keys and their number of occurances in the original list.
(: count-by (All (T Key) (-> (-> T Key) (Listof T) (Listof (Tuple Key Integer)))))
(define (count-by projection input)
  (~>> (fold (fn ([state : (HashTable Key Integer)] [value : T])
                 (define key (projection value))
                 (if (Map.contains-key key state)
                     (Map.add key (+ (Map.get key state) 1) state)
                     (Map.add key 1 state)))
             (ann (hash) (HashTable Key Integer))
             input)
       (Map.to-list)))

; Returns a list that contains no duplicate entries. If an element occurs multiple times in the list
; then the later occurances are discarded.
(: distinct (All (T) (-> (Listof T) (Listof T))))
(define (distinct input)
  (~>> (fold (fn ([state : (HashTable T T)] [value : T])
                 (if (Map.contains-key value state) state (Map.add value value state)))
             (ann (hash) (HashTable T T))
             input)
       (Map.keys)))

; Returns a list that contains no duplicate entries based on the key generating function.
; If an elements occurs multiple times it is discarded.
(: distinct-by (All (T Key) (-> (-> T Key) (Listof T) (Listof T))))
(define (distinct-by projection input)
  (~>> (fold (fn ([state : (HashTable Key T)] [value : T])
                 (define key (projection value))
                 (if (Map.contains-key key state) state (Map.add key value state)))
             (ann (hash) (HashTable Key T))
             input)
       (Map.get-values)))

; Returns the only element of the list.
(: exactly-one (All (T) (-> (Listof T) T)))
(define (exactly-one input)
  (if (= (length input) 1) (car input) (error "Expected a list with exactly one element.")))

; Tests if any element of the list satisifes the given predicate.
(: exists (All (T) (-> (-> T Boolean) (Listof T) Boolean)))
(define (exists predicate input)
  (cond
    [(null? input) #f]
    [(predicate (car input)) #t]
    [else (exists predicate (cdr input))]))

; Tests if any pair of corresponding elements of the lists satisifes the given predicate.
(: exists-two (All (T S) (-> (-> T S Boolean) (Listof T) (Listof S) Boolean)))
(define (exists-two predicate list-one list-two)
  (cond
    [(or (null? list-one) (null? list-two)) #f]
    [(predicate (car list-one) (car list-two)) #t]
    [else (exists-two predicate (cdr list-one) (cdr list-two))]))

; Returns a new collection containing only the elements of the collection for which the
; given predciate returns true.
(: filter (All (T) (-> (-> T Boolean) (Listof T) (Listof T))))
(define (filter predicate input)
  (cond
    [(null? input) '()]
    [(predicate (car input)) (cons (car input) (filter predicate (cdr input)))]
    [else (filter predicate (cdr input))]))

; Returns the first element for which the given function returns true otherwise, false.
(: find (All (T) (-> (-> T Boolean) (Listof T) (U T False))))
(define (find predicate input)
  (cond
    [(null? input) #f]
    [(predicate (car input)) (car input)]
    [else (find predicate (cdr input))]))

; Returns the first element for which the given function returns true.
(: find-index (All (T) (-> (-> T Boolean) (Listof T) (U Number False))))
(define (find-index predicate input)
  (let loop ([index 0] [predicate predicate] [input input])
    (cond
      [(null? input) #f]
      [(predicate (car input)) index]
      [else (loop (+ index 1) predicate (cdr input))])))

; Returns the last element for which the given function returns true.
(: find-index-back (All (T) (-> (-> T Boolean) (Listof T) (U Number False))))
(define (find-index-back predicate input)
  (let loop ([index (- (length input) 1)] [predicate predicate] [input (reverse input)])
    (cond
      [(null? input) #f]
      [(predicate (car input)) index]
      [else (loop (- index 1) predicate (cdr input))])))

; Applies a function to each element of the collection, threading an accumulator
; argument through the computation.
(: fold (All (T State) (-> (-> State T State) State (Listof T) State)))
(define (fold folder state input)
  (if (null? input) state (fold folder (folder state (car input)) (cdr input))))

; Applies a function to each element of the two collections, threading an accumulator
; argument through the computation. Each collection must have the same size.
(: fold-two (All (T S State) (-> (-> State T S State) State (Listof T) (Listof S) State)))
(define (fold-two folder state list-one list-two)
  (when (not (= (length list-one) (length list-two)))
    (error "Two lists must be the same size."))

  (if (null? list-one)
      state
      (fold-two folder (folder state (car list-one) (car list-two)) (cdr list-one) (cdr list-two))))

; Tests if all elemetns of the colleciton staisfy a given predicate.
(: for-all (All (T) (-> (-> T Boolean) (Listof T) Boolean)))
(define (for-all predicate list)
  (if (contains #f (map predicate list)) #f #t))

; Applies a key-generating function to each element of a list and yields
; a list of unique keys. Each unique key contains a list of all elements that match
; to this key.
;(: group-by (All (T Key) (-> (-> T Key) (Listof T) (Listof (Pairof Key (Listof T))))))
;(define (group-by projection input)
;  )

(module+ test
  (require typed/rackunit)

  (struct Person ([Name : String] [Age : Integer]) #:transparent)
  (define people
    :
    (Listof Person)
    (list (Person "Jim" 22)
          (Person "Tim" 55)
          (Person "Tim" 23)
          (Person "Ted" 33)
          (Person "Peter" 55)
          (Person "Elana" 18)
          (Person "Peter" 44)
          (Person "Jim" 33)))

  (test-equal? "All-pairs works."
               (all-pairs '(1 2 3 4) '(1 2 3 4))
               (list (Tuple 1 1) (Tuple 2 2) (Tuple 3 3) (Tuple 4 4)))

  (test-equal? "Append works." (append '(1 2 3 4) '(1 2 3 4)) '(1 2 3 4 1 2 3 4))

  (test-equal? "Average works." (average '(3 3 3 3 6 6 6 6)) 9/2)

  (test-equal? "Average-by works."
               (average-by (fn ([x : String]) (string-length x)) '("one" "one" "two"))
               3)

  (test-true "Contains returns true." (contains 2 '(1 2 3)))

  (test-false "Contains returns false." (contains "one" '("two" "three" "four")))

  (test-equal? "Count-by works."
               (count-by (fn ([x : (Tuple Integer Integer)]) (Tuple-First x))
                         (list (Tuple 1 2) (Tuple 2 3) (Tuple 2 3) (Tuple 3 3)))
               (list (Tuple 1 1) (Tuple 2 2) (Tuple 3 1)))

  (test-equal? "Count-by more fun works."
               (count-by (fn ([x : (Tuple Symbol String)]) (Tuple-First x))
                         (list (Tuple 'a "2")
                               (Tuple 'b "3")
                               (Tuple 'a "23")
                               (Tuple 'b "44")
                               (Tuple 'c "a")
                               (Tuple 'a "23")))
               (list (Tuple 'c 1) (Tuple 'b 2) (Tuple 'a 3)))

  (test-equal? "Distinct works." (distinct (list 1 2 3 4 4 1)) (list 1 2 3 4))

  (test-equal? "Distinct works, strings."
               (distinct (list "One" "One" "One" "Two" "Three"))
               (list "One" "Three" "Two"))

  (test-equal? "Distinct-by works"
               (distinct-by (fn ([x : Person]) (Person-Name x)) people)
               (list (Person "Peter" 55)
                     (Person "Ted" 33)
                     (Person "Tim" 55)
                     (Person "Elana" 18)
                     (Person "Jim" 22)))

  (test-eq? "Exactly-one works." (exactly-one '(1)) 1)

  (test-exn "Exactly-one throws." exn:fail? (fn () (exactly-one '(1 2))))

  (test-true "Exists returns true." (exists (fn ([x : Integer]) (= x 1)) '(4 3 2 1)))

  (test-false "Exists returns false."
              (exists (fn ([x : String]) (equal? x "One")) '("two" "three" "four")))

  (test-true "Exists-two returns true."
             (exists-two (fn ([x : Integer] [y : Integer]) (> (+ x y) 1)) '(0 0 0 1) '(0 0 0 1)))

  (test-false "Exists-two returns false."
              (exists-two (fn ([x : Integer] [y : Integer]) (> (+ x y) 1)) '(0 0 0 0) '(0 0 0 0)))

  (test-equal? "Filter works."
               (filter (fn ([x : Integer]) (= (modulo x 2) 0)) '(1 2 3 4 5 6))
               '(2 4 6))

  (test-equal? "Find works, returns value."
               (find (fn ([x : String]) (> (string-length x) 2)) '("1" "one"))
               "one")

  (test-false "Find works, returns none" (find (fn ([x : Integer]) (= 0 x)) '(1 2 3 4)))

  (test-eq? "Find-index works, returns index."
            (find-index (fn ([x : Integer]) (= 0 x)) '(1 2 0 3 4))
            2)

  (test-false "Find-index works, returns false." (find-index (fn ([x : Integer]) (= 0 x)) '(1 2 3 4)))

  (test-eq? "Find-index-back works." (find-index-back (fn ([x : Integer]) (= 0 x)) '(4 3 2 0 1)) 3)

  (test-eq? "Fold works." (fold (fn ([state : Integer] [x : Integer]) (+ x state)) 0 '(1 2 3 4)) 10)

  (test-true "For-all returns true." (for-all (fn ([x : Integer]) (= x 1)) '(1 1 1 1)))

  (test-false "For-all returns false." (for-all (fn ([x : Integer]) (= x 1)) '(1 2 3 4 5))))
