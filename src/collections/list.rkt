#lang typed/racket/base/deep

(require "../globals.rkt")

; Returns a new list that contains all pairings of elements from two lists.
(: all-pairs (All (T) (-> (Listof T) (Listof T) (Listof (List T T)))))
(define (all-pairs list-one list-two)
  (cond
    [(null? (cdr list-one)) (cons (list (car list-one) (car list-two)) '())]
    [else (cons (list (car list-one) (car list-two)) (all-pairs (cdr list-one) (cdr list-two)))]))

; Returns a new list that contains the elements of the first list followed by
; elements of the second list.
(: append (All (T) (-> (Listof T) (Listof T) (Listof T))))
(define (append list-one list-two)
  (if (null? list-one) list-two (cons (car list-one) (append (cdr list-one) list-two))))

; Returns the average of the values in a non-empty list.
(: average (-> (Listof Number) Number))
(define (average source)
  (/ (apply + source) (length source)))

; Returns the average of values in a list generated by applying a function to each
; element of the list.
(: average-by (All (T) (-> (-> T Number) (Listof T) Number)))
(define (average-by projection source)
  (average (map projection source)))

; Applies a fucntion to each element in a list and then returns a list of values v where
; the applied function returns Some(v). Returns an empty list when the input list is empty
; or when the applied chooser function returns None for all elements.
;(: choose (All (T U) (-> (-> T (Option U)) (Listof T) (Listof U))))
;(define (choose chooser source)
;  (if (is-empty? source) '() (cons (chooser (car source)) (choose chooser (cdr source)))))

(define (chunk-by-size chunk-size source)
  (raise "Not implemented."))

(define (collect mapping source)
  (raise "Not implemented"))

(define (compare-with comparer list-one list-two)
  (raise "Not implemented"))

(define (concat lists)
  (raise "Not implemented"))

; Tests if the list contains the specified element.
(: contains (All (T) (-> T (Listof T) Boolean)))
(define (contains value source)
  (cond
    [(null? source) #f]
    [(equal? (car source) value) #t]
    [else (contains value (cdr source))]))

(define (count-by projection source)
  (raise "Not implemented."))

(define (distinct source)
  (raise "Not implemented."))

(define (distinct-by projection source)
  (raise "Not implemented."))

; Returns an empty list of the given type..
(: empty (All (T) (-> (Listof T))))
(define (empty)
  '())

; Returns the only element of the list.
(: exactly-one (All (T) (-> (Listof T) (Option T))))
(define (exactly-one source)
  (if (= (length source) 1) (car source) #f))

; Tests is any element of teh list satifies the given predicate.
(: exists (All (T) (-> (-> T Boolean) (Listof T) Boolean)))
(define (exists predicate source)
  (cond
    [(null? source) #f]
    [(predicate (car source)) #t]
    [else (exists predicate (cdr source))]))

; Tests if any pair of corresponding elements of the lists satisfies the given predicate.
(: exists-two (All (T) (-> (-> T T Boolean) (Listof T) (Listof T) Boolean)))
(define (exists-two predicate list-one list-two)
  (cond
    [(and (null? list-one) (null? list-two)) #f]
    [(predicate (car list-one) (car list-two)) #t]
    [(null? (cdr list-one)) (exists-two predicate list-one (cdr list-two))]
    [else (exists-two predicate (cdr list-one) list-two)]))

; Returns a new collection continaing only the elements of the collection for which the
; the given predicate returns true.
(: filter (All (T) (-> (-> T Boolean) (Listof T) (Listof T))))
(define (filter predicate source)
  (cond
    [(null? source) '()]
    [(predicate (car source)) (cons (car source) (filter predicate (cdr source)))]
    [else (filter predicate (cdr source))]))

; Returns the first element for which the given function returns True.
(: find (All (T) (-> (-> T Boolean) (Listof T) (Option T))))
(define (find predicate source)
  (cond
    [(null? source) #f]
    [(predicate (car source)) (car source)]
    [else (find predicate (cdr source))]))

; Returns the last element for which the given function returns True.
(: find-back (All (T) (-> (-> T Boolean) (Listof T) (Option T))))
(define (find-back predicate source)
  (define reverse-source (reverse source))
  (cond
    [(null? reverse-source) #f]
    [(predicate (car reverse-source)) (car reverse-source)]
    [else (find predicate (cdr reverse-source))]))

; Find the index of the given item.
(:)
(: find-index (All (T) (-> (-> T Boolean) (Listof T) Integer)))
(define (find-index predicate source)
  (let loop ([index 0] [predicate predicate] [source source])
    (cond
      [(null? source) #f]
      [(predicate (car source)) index]
      [else (loop (+ index 1) predicate (cdr source))])))

(: find-index-back (All (T) (-> (-> T Boolean) (Listof T) Integer)))
(define (find-index-back predicate source)
  (define reverse-source (reverse source))
  (define count (- (length source) 1))

  (let loop ([index count] [predicate predicate] [source reverse-source])
    (cond
      [(null? source) #f]
      [(predicate (car source)) index]
      [else (loop (- index 1) predicate (cdr source))])))

(define (fold folder state source)
  (cond
    [(null? source) state]
    [else (fold folder (folder state (car source)) (cdr source))]))

(define (fold-two folder state list-one list-two)
  (cond
    [(and (null? list-one) (null? list-two)) state]
    [(and (null? (cdr list-one)) (not (null? (cdr list-two))))
     (fold-two folder (folder state (car list-one) (car list-two)) list-one (cdr list-two))]
    [(and (null? (cdr list-two)) (not (null? (cdr list-one))))
     (fold-two folder (folder state (car list-one) (car list-two)) (cdr list-one) list-two)]
    [else
     (fold-two folder (folder state (car list-one) (car list-two)) (cdr list-one) (cdr list-two))]))

(define (fold-back folder state source)
  (define reverse-source (reverse source))
  (fold folder state reverse-source))

(define (fold-back-two folder state list-one list-two)
  (define list-one-reverse (reverse list-one))
  (define list-two-reverse (reverse list-two))

  (cond
    [(and (null? list-one-reverse) (null? list-two-reverse)) state]
    [(and (null? (cdr list-one-reverse)) (not (null? (cdr list-two-reverse))))
     (fold-two folder
               (folder state (car list-one-reverse) (car list-two-reverse))
               list-one-reverse
               (cdr list-two-reverse))]
    [(and (null? (cdr list-two-reverse)) (not (null? (cdr list-one-reverse))))
     (fold-two folder
               (folder state (car list-one-reverse) (car list-two-reverse))
               (cdr list-one-reverse)
               list-two-reverse)]
    [else
     (fold-two folder
               (folder state (car list-one-reverse) (car list-two-reverse))
               (cdr list-one-reverse)
               (cdr list-two-reverse))]))

(define (for-all predicate source)
  (if (> (length (filter predicate source)) 0) #t #f))

(define (for-all-two predicate list-one list-two)
  (raise "Not implemented."))

(define (group-by projection source)
  (raise "Not implemented."))

(define (head source)
  (if (null? source) #f (car source)))

(: indexed (All (T) (-> (Listof T) (Listof (Pairof Integer T)))))
(define (indexed source)
  (let loop ([index 0] [source source])
    (cond
      [(null? source) '()]
      [(append (list (cons index (car source))) (loop (+ 1 index) (cdr source)))])))

(: init (All (T) (-> Integer (-> Integer T) (Listof T))))
(define (init count
              initializer)
  (let loop ([index 0] [count count] [initializer initializer])
    (cond
      [(= index count) '()]
      [else (cons (initializer index) (loop (+ 1 index) count initializer))])))

; TODO: Build a splitter.
(define (insert index value source)
  (raise "Not implemented."))

; TODO: list-insert-many-at

(define (is-empty? source)
  (null? source))

(: item (All (T) (-> Integer (Listof T) T)))
(define (item index source)
  (let loop ([acc 0] [index index] [source source])
    (cond
      [(null? source) #f]
      [(= acc index) (car source)]
      [else (loop (+ 1 acc) index (cdr source))])))

(define (iter action source)
  (cond
    [(null? source) (void)]
    [else
     (action (car source))
     (iter action (cdr source))]))

; TODO: Finish all cases and test.
(define (iter-two action list-one list-two)
  (cond
    [(and (null? list-one) (null? list-two)) (void)]
    [(and (null? (cdr list-two)) (not (null? (cdr list-one))))
     (action (car list-one) (car list-two))
     (iter-two action (cdr list-one) list-two)]))

(: iter-index (All (T) (-> (-> T Void) (Listof T) Void)))
(define (iter-index action source)
  (let loop ([index 0] [action action] [source source])
    (cond
      [(null? source) (void)]
      [else
       (action index (car source))
       (loop (+ 1 index) action (cdr source))])))

(define (iter-index-two action list-one list-two)
  (when (not (= (length list-one) (length list-two)))
    (raise "Arguments must be the same length to list-iter-index-two."))
  (let loop ([index 0] [action action] [list-one list-one] [list-two list-two])
    (cond
      [(null? list-one) (void)]
      [else
       (action index (car list-one) (car list-two))
       (loop (+ 1 index) action (cdr list-one) (cdr list-two))])))

(define (last source)
  (if (null? source) #f (item (- (length source) 1) source)))

(define (length source)
  (if (null? source) 0 (+ 1 (length (cdr source)))))

(define (map mapping source)
  (cond
    [(null? source) '()]
    [else (cons (mapping (car source)) (map mapping (cdr source)))]))

; TODO: map-two
; TODO: map-three
; TODO: map-fold - returns the list and accumulated value as a pair.
; TODO: map-fold-back - same as above but with a reversed list.

(: map-index (All (T U) (-> (-> Integer T U) (Listof T) (Listof U))))
(define (map-index mapping source)
  (let loop ([index 0] [mapping mapping] [source source])
    (cond
      [(null? source) '()]
      [else (cons (mapping index (car source)) (loop (+ 1 index) mapping (cdr source)))])))

; TODO: map-index-two - Lists same length.

; TODO: Come back to fix the wonky type checking.
(define (max source)
  (fold (fn (max-num item) (if (< max-num item) item max-num)) -320000 source))

; TODO: list-max-by
; TODO: list-min
; TODO: list-min-by

(: of-array (All (T) (-> (Vectorof T) (Listof T))))
(define (of-array array)
  (let loop ([index 0] [array array])
    (cond
      [(= index (vector-length array)) '()]
      [else (cons (vector-ref array index) (loop (+ index 1) array))])))

; TODO: list-of-seq
; TODO: list-pairwise
; TODO: list-partition - filter but keep true and false. (Pair (Listof T) (Listof T))
; TODO: list-permute - I have no idea how this works. Will have to see the source.

; TODO: Fix (: list-pick (All (T U) (-> (-> T (Option U)) (Listof T) (Option U))))

; TODO: list-remove-at

(define (split-at index source)
  (list (take index source) (skip index source)))

(define (skip count source)
  (when (> count (length source))
    (raise "Index is greater than the bounds of the list."))
  (let loop ([index 0] [count count] [source source])
    (cond
      [(null? source) '()]
      [(< index count) (loop (+ 1 index) count (cdr source))]
      [else (cons (car source) (loop (+ 1 index) count (cdr source)))])))

; (: list-split-into) Don't know how to determine how big each chunk should be.

(define (sum source)
  (fold (fn (acc item) (+ acc item)) 0 source))

; list-sum-by

(define (tail source)
  (cdr source))

(define (take count source)
  (when (> count (length source))
    (raise "Index is greater than the bounds of the list."))
  (let loop ([index 0] [count count] [source source])
    (cond
      [(= index count) '()]
      [else (cons (car source) (loop (+ 1 index) count (cdr source)))])))

(define (take-while predicate source)
  (cond
    [(null? source) '()]
    [(not (predicate (car source))) '()]
    [else (cons (car source) (take-while predicate (cdr source)))]))

; TODO: Change this to my own implementation.
(define (to-array source)
  (list->vector source))

; TODO: list->seq

; TODO: list->transpose

; TODO: list->truncate

; TODO: list-unfold, no idea how to implement

; TODO: list-unzip

; TODO: list-unzip-threeple

(define (sort-ascending source)
  (sort source <))

(define (sorty-by projection source)
  (sort source < #:key projection))

(define (sorty-by-descending projection source)
  (sort source > #:key projection))

(define (sort-descending source)
  (sort source >))

(: update-at (All (T) (-> Integer T (Listof T) (Listof T))))
(define (update-at index value source)
  (let loop ([current 0] [index index] [value value] [source source])
    (cond
      [(null? source) '()]
      [(= current index) (cons value (loop (+ 1 current) index value (cdr source)))]
      [else (cons (car source) (loop (+ 1 current) index value (cdr source)))])))

; TODO: list-windowed

; TODO: list-zip - must be equal

; TODO: list-zip-three

(provide (all-defined-out))

(module+ test
  (require typed/rackunit)
  (define names '("tom" "cindy" "billy"))
  (define list-one '(1 2 3 4))
  (define list-two '(4 5 6 7))

  (test-true "Exists-two passes." (exists-two (fn (x y) (= (+ x y) 5)) list-one list-two))

  ;(test-false "Exists-two fails." (exists-two (fn (x y) (= (+ x y) -1)) list-one list-two))

  (define source '("one" "two" "three"))

  (test-equal? "Filter out any item that is string length bigger than 5."
               (filter (fn (item) (< (string-length item) 5)) source)
               '("one" "two"))

  (test-eq? "Fold two lists together to get the total."
            (fold-two (fn (state item-one item-two) (+ state item-one (string-length item-two)))
                      0
                      '(1 2 3)
                      '("one" "two" "three"))
            17)

  (test-equal? "Appending to a list works." (append (list 1 2 3) (list 4 5 6)) (list 1 2 3 4 5 6))

  (test-eq? "Average of a list works." (average (list 0 0 1 4 5)) 2)

  (test-equal? "Average-by of a list works correctly."
               (average-by (fn (x) (string-length x)) names)
               13/3)

  (test-true "Contains finds that 3 is in the list." (contains 3 '(1 2 3)))

  (test-false "Contains can't find 'test' in the list." (contains "test" '("one")))

  (test-eq? "The list is empty." (empty) '())

  (test-eq? "Exactly-one is true because the list has one element." (exactly-one '(1)) 1)

  (test-true "Exists returns true because the predicate works on the list."
             (exists (fn (x) (> x 1)) '(1 2 3)))

  (test-false "Exists returns false because the predicate isn't in the list."
              (exists (fn (x) (< x 1)) '(1 2 3)))

  (test-eq? "Find works and finds 5 in the list." (find (fn (item) (= item 5)) '(1 2 3 5 4)) 5)

  (test-false "Find returns false, there is no 1 in the list."
              (find (fn (item) (= item 1)) '(2 3 4 5)))

  (test-eq? "Find back finds 4 in the list." (find-back (fn (item) (= item 4)) '(1 2 3 5 4)) 4)

  (test-false "Find back doesn't find 0 in the list." (find-back (fn (item) (= item 0)) '(2 3 4 5)))

  (test-eq? "Find index finds 1 is the index of 3." (find-index (fn (item) (= item 3)) '(1 3 4 5)) 1)

  (test-false "Find index returns false, test isn't in the list."
              (find-index (fn (item) (equal? item "Test")) names))

  (test-eq? "Find index back finds the index of 3 is 1."
            (find-index-back (fn (item) (= item 3)) '(1 3 4 5))
            1)

  (test-false "Find index back returns false, Tim isn't in the list."
              (find-index-back (fn (item) (equal? item "Tim")) names))

  (test-eq? "Fold adds up the list to it's sum." (fold (fn (state item) (+ state item)) 0 '(1 2 3)) 6)

  (test-equal? "Fold appends the strings together correctly."
               (fold (fn (state item) (string-append state " " item)) "" '("one" "two" "three"))
               " one two three")

  (test-equal? "Fold back works correctly by dividing the items in the list."
               (fold-back (fn (state item) (/ item state)) 2 '(256 4048 24))
               192/253)

  (test-true "For all is true, every item is 1." (for-all (fn (item) (= 1 item)) '(1 1 1 1)))

  (test-false "For all is false, the list is empty." (for-all (fn (item) (= 1 item)) '()))

  (test-eq? "Getting the head of the list works." (head '(1 2 3 4)) 1)

  (test-equal? "Indexing the list works." (indexed '(1 2 3)) '((0 . 1) (1 . 2) (2 . 3)))

  (test-equal? "Init the list works."
               (init 4
                     (fn (item) (+ item 5)))
               '(5 6 7 8))

  (test-eq? "Getting the item by index works." (item 1 '(1 2 3 4)) 2)

  (test-false "Getting returns false because the list is empty." (item 1 '()))

  (test-false "Last returns false because the list is empty." (last '()))

  (test-eq? "Last returns 100." (last '(1 2 3 4 25 100)) 100)

  (test-eq? "Length gets the correct lenght of the list." (length '(1 2 3 4)) 4)

  (test-equal? "Mapping over the list works." (map (fn (item) (+ item 2)) '(1 2 3 4)) '(3 4 5 6))

  (test-equal? "Map index works correctly."
               (map-index (fn (index item) (+ index item)) '(1 2 3 4))
               '(1 3 5 7))

  (test-eq? "Getting the max of the list works." (max '(1 2 3 4)) 4)

  (test-equal? "Getting the max of the double list works." (max '(100.35 .33 .25 10.99)) 100.35)

  (test-equal? "Converting the array to a list works." (of-array #(1 2 3 4)) '(1 2 3 4))

  (test-equal? "Skipping works." (skip 1 '(1 2 3 4)) '(2 3 4))

  (test-equal? "Taking works." (take 2 '(1 2 3 4)) '(1 2))

  (test-equal? "Splitting the list works."
               (split-at 3 '(8 4 3 1 6 1))
               (list (list 8 4 3) (list 1 6 1)))

  (test-equal? "Splitting works part 2." (split-at 2 '(1 2 3 4 5)) (list (list 1 2) (list 3 4 5)))

  (test-eq? "Summing ints works." (sum '(1 2 3 4)) 10)

  (test-equal? "Summing doubles works." (sum '(1.0 2.0 3.4 4.0)) 10.4)

  (test-equal? "Take while works."
               (take-while (fn (item) (not (= item 4))) '(1 2 3 4 5 6 7))
               '(1 2 3))

  (test-equal? "Update at works." (update-at 1 3 '(1 2 3 4)) '(1 3 3 4))

  (test-equal? "Sort-ascending works." (sort-ascending '(4 2 3 1)) '(1 2 3 4))

  (test-equal? "Sort-descending works." (sort-descending '(4 2 3 1)) '(4 3 2 1))

  (define unordered-pairs (list (list 4 "four") (list 2 "two") (list 3 "three")))

  (test-equal? "Sort-by works."
               (sorty-by (fn (x) (car x)) unordered-pairs)
               (list (list 2 "two") (list 3 "three") (list 4 "four")))

  (test-equal? "Sort-by-descending works."
               (sorty-by-descending (fn (x) (car x)) unordered-pairs)
               (list (list 4 "four") (list 3 "three") (list 2 "two"))))
