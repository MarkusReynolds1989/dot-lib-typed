#lang typed/racket/base/deep

(require "../globals.rkt"
         (prefix-in Map. "map.rkt")
         threading
         racket/match)

; Returns a new list that contains all pairings of elements from two lists.
#| (: all-pairs (All (T S) (-> (Listof T) (Listof S) (Listof (Pairof T S)))))
(define (all-pairs list-one list-two)
  (if (null? list-one)
      '()
      (append (map (lambda (x) (cons (car list-one) x)) list-two)
              (all-pairs (cdr list-one) list-two)))) |#

; Returns a new list that contains the elements of the first list followed by
; elements of the second list.
(: append (All (T) (-> (Listof T) (Listof T) (Listof T))))
(define (append list-one list-two)
  (if (null? list-one) list-two (cons (car list-one) (append (cdr list-one) list-two))))

; Returns the average of the values in a non-empty list.
(: average (-> (Listof Number) Number))
(define (average source)
  (when (= 0 (length source))
    (error "List empty error."))
  (/ (apply + source) (length source)))

; Returns the average of values in a list generated by applying a function to each
; element of the list.
(: average-by (All (T) (-> (-> T Number) (Listof T) Number)))
(define (average-by projection source)
  (when (= 0 (length source))
    (error "List empty error."))
  (average (map projection source)))

; Tests if the list contains the specified element.
(: contains (All (T) (-> T (Listof T) Boolean)))
(define (contains value source)
  (cond
    [(null? source) #f]
    [(equal? (car source) value) #t]
    [else (contains value (cdr source))]))

; TODO: The problem here is that if I just use tuples or something it's going to be very
; slow to iterate the list, it would be better to have a Map.fold first
; and use that.

; Applies a key-generating function to each element of a list and returns a list
; yielding unique keys and their number of occurances in the original list.
;(: count-by (All (T Key) (-> (-> T Key) (Listof T) (Listof (Pairof Key Integer)))))
;(define (count-by projection input)
;  (~>> (fold (fn ([x : T] [state : (HashTable Key T)])
;                 (define key : Key (projection x))
;                 (if (Map.contains-key key state)
;                     (Map.update key (+ (Map.get key state) 1) state)
;                     (Map.add key 1 state)))
;             (make-hash)
;             input)
;       (Map.to-list)))

; Returns the only element of the list.
(: exactly-one (All (T) (-> (Listof T) T)))
(define (exactly-one input)
  (if (= (length input) 1) (car input) (error "Expected a list with exactly one element.")))

; Tests if any element of the list satisifes the given predicate.
(: exists (All (T) (-> (-> T Boolean) (Listof T) Boolean)))
(define (exists predicate input)
  (cond
    [(null? input) #f]
    [(predicate (car input)) #t]
    [else (exists predicate (cdr input))]))

; Returns a new collection containing only the elements of the collection for which the
; given predciate returns true.
(: filter (All (T) (-> (-> T Boolean) (Listof T) (Listof T))))
(define (filter predicate input)
  (cond
    [(null? input) '()]
    [(predicate (car input)) (cons (car input) (filter predicate (cdr input)))]
    [else (filter predicate (cdr input))]))

; Returns the first element for which the given function returns true otherwise, false.
(: find (All (T) (-> (-> T Boolean) (Listof T) (U T False))))
(define (find predicate input)
  (cond
    [(null? input) #f]
    [(predicate (car input)) (car input)]
    [else (find predicate (cdr input))]))

(: find-index (All (T) (-> (-> T Boolean) (Listof T) (U Number False))))
(define (find-index predicate input)
  (let loop ([index 0] [predicate predicate] [input input])
    (cond
      [(null? input) #f]
      [(predicate (car input)) index]
      [else (loop (+ index 1) predicate (cdr input))])))

(: fold (All (T State) (-> (-> T State State) State (Listof T) State)))
(define (fold folder state input)
  (if (null? input) state (fold folder (folder (car input) state) (cdr input))))

; Tests if all elemetns of the colleciton staisfy a given predicate.
(: for-all (All (T) (-> (-> T Boolean) (Listof T) Boolean)))
(define (for-all predicate list)
  (if (contains #f (map predicate list)) #f #t))

; Applies a key-generating function to each element of a list and yields
; a list of unique keys. Each unique key contains a list of all elements that match
; to this key.
;(: group-by (All (T Key) (-> (-> T Key) (Listof T) (Listof (Pairof Key (Listof T))))))
;(define (group-by projection input)
;  )

(module+ test
  (require typed/rackunit)

  (test-equal? "Append works." (append '(1 2 3 4) '(1 2 3 4)) '(1 2 3 4 1 2 3 4))

  (test-equal? "Average works." (average '(3 3 3 3 6 6 6 6)) 9/2)

  (test-equal? "Average-by works."
               (average-by (fn ([x : String]) (string-length x)) '("one" "one" "two"))
               3)

  (test-true "Contains returns true." (contains 2 '(1 2 3)))

  (test-false "Contains returns false." (contains "one" '("two" "three" "four")))

  (test-eq? "Exactly-one works." (exactly-one '(1)) 1)

  (test-exn "Exactly-one throws." exn:fail? (fn () (exactly-one '(1 2))))

  (test-true "Exists returns true." (exists (fn ([x : Integer]) (= x 1)) '(4 3 2 1)))

  (test-false "Exists returns false."
              (exists (fn ([x : String]) (equal? x "One")) '("two" "three" "four")))

  (test-equal? "Filter works."
               (filter (fn ([x : Integer]) (= (modulo x 2) 0)) '(1 2 3 4 5 6))
               '(2 4 6))

  (test-equal? "Find works, returns value."
               (find (fn ([x : String]) (> (string-length x) 2)) '("1" "one"))
               "one")

  (test-false "Find works, returns none" (find (fn ([x : Integer]) (= 0 x)) '(1 2 3 4)))

  (test-eq? "Find-index works, returns index."
            (find-index (fn ([x : Integer]) (= 0 x)) '(1 2 0 3 4))
            2)

  (test-false "Find-index works, returns false." (find-index (fn ([x : Integer]) (= 0 x)) '(1 2 3 4)))

  (test-eq? "Fold works." (fold (fn ([x : Integer] [state : Integer]) (+ x state)) 0 '(1 2 3 4)) 10)

  (test-true "For-all returns true." (for-all (fn ([x : Integer]) (= x 1)) '(1 1 1 1)))

  (test-false "For-all returns false." (for-all (fn ([x : Integer]) (= x 1)) '(1 2 3 4 5))))
