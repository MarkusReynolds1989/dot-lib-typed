#lang typed/racket/base

(require "../globals.rkt"
         (prefix-in Map. "map.rkt")
         racket/vector
         threading)

; Returns an empty array.
(define (empty)
  (Array (vector)))

(: length (All (T) (-> (Array T) Integer)))
(define (length array)
  (vector-length (Array-v array)))

; Gets an element of an array.
(: get (All (T) (-> (Array T) Integer T)))
(define (get input index)
  (vector-ref (Array-v input) index))

(: append (All (T) (-> (Array T) (Array T) (Array T))))
(define (append array-one array-two)
  (Array (vector-append (Array-v array-one) (Array-v array-two))))

; Returns a new array that contains all pairings of elements from the first and second arrays.
;(: all-pairs (All (T U) (-> (Array T) (Array T) (Array (List T U)))))
;(define (all-pairs array-one array-two)

;  (define result (empty))

;  (for ([index (in-range 0 (length array-one))])
;    (set! result (append result (vector (list (get array-one index) (get array-two index))))))
;  result)

; Builds a new array that contains the elements of the first
; array followed by the elements of the second.
#| (: append (All (T U) (-> (Vectorof T) (Vectorof U) (Vector T U))))
(define (append array-one array-two)
  (vector-append array-one array-two))

; Returns the average of the elements of the array.
(define (average input)

  (/ (sum input) (length input)))

; Returns the average of the elements generated by applying the function
; to each element of the array.
(define (average-by projection input)
  (define mapped-values (map projection input))
  (average mapped-values))

; Reads a range of elements from the first array and write them into the second.
(define (blit dest dest-start src [src-start 0] [src-end (length src)])
  (vector-copy! dest dest-start src src-start src-end))

; TODO: choose - May only need to be used for typed racket where we have an option type.
; Applies the given function to each element of the array. Returns the new array
; comprised of the results x for each element where the function returns Some(x).

; Divides the input array into chunks of size at most chunk-size.
(: chunk-by-size (All (T) (-> Number Number (Vectorof T) (Vectorof (Listof T)))))
(define (chunk-by-size chunk-size input)
  (let loop ([index 0] [chunk-size chunk-size] [input input])
    (cond
      [(= index (- (+ (length input) 1) chunk-size)) #()]
      [(append (vector (~>> (skip index input) (take chunk-size)))
               (loop (+ index 1) chunk-size input))])))

; TODO: collect - implement map and concat
; For each element of the array, applies the given function. Concatenates all the results and
; return the combined array.

; TODO: compare-with
; Compares two arrays using the givern comparison function, element by element.

; TODO: concat - may not need this, this is to take Seqs of arrays and concat them into one.

; Tests if the array contains the specified element.
(: contains (All (T) (-> T (Vectorof T) Boolean)))
(define (contains value input)
  (let loop ([index 0] [value value] [input input])
    (cond
      [(= index (length input)) #f]
      [(equal? (get input index) value) #t]
      [else (loop (+ 1 index) value input)])))

; Builds a new array that contains the elements of the array given.
(define (copy input)
  (define new-array (create (length input) (get input 0)))
  (blit new-array 0 input)
  new-array)

; Applies a key-generating function to each element of an array and returns an array
; yielding unique keys and their number of occurrences in the original array.
; Fold over a map, increment the value everytime the key is found again. Then return the map
; as an array.
;(define (count-by projection input)
;  (~>> (fold (fn (state x)
;                 (define key (projection x))
;                 (if (Map.contains-key key state)
;                     (Map.change key (+ (Map.get key state) 1) state)
;                     (Map.add key 1 state)))
;             (Map.empty)
;             input)
;       (Map.to-array)))

; Creates an array whose elements are all initially the given value.
(define (create count init-value)
  (make-vector count init-value))

; Returns an array that contains no duplicate entries according to generic hash and
; equality compairsons on the entries. If an element occurs multiple times in the
; array then the later occurences are discarded.
; (define (distinct input)
;  (~>>
;   (fold (fn (state x) (if (Map.contains-key x state) state (Map.add x 1 state))) (Map.empty) input)
;   (Map.keys)
;   (List.to-array)))

; Returns an array that contains no duplicate entries according to the
; generic hash and comparisons on keys returned by the give key-generating function.
; If an element occurs multiple times in teh array then the later
; occurences are discarded.
; (define (distinct-by projection input)
;  (~>> input (map (fn (x) (projection x))) (distinct)))


; Returns the only element of an array.
(define (exactly-one array)
  (and (= (length array) 1) (get array 0)))

; TODO: except - Come back to this after sequence is ready.
; Returns a new list with the distinct elements of the input array with do not appear
; in the items-to-exclude sequence, using generic hash and equality comparison to compare values.

; Tests if any element of the array satisfies the given predicate.
(define (exists predicate array)
  (cond
    [(= (length array) 0) #f]
    [(= (length array) 1) (predicate (get array 0))]
    [(> (length array) 1)
     (let loop ([low-pointer 0]
                [high-pointer (- (length array) 1)]
                [predicate predicate]
                [array array])
       (cond
         [(= high-pointer low-pointer) #f]
         [(or (predicate (get array low-pointer)) (predicate (get array high-pointer))) #t]
         [else (loop (+ 1 low-pointer) (- high-pointer 1) predicate array)]))]))

; Tests if any pair of corresponding elements of the arrays satisifes the given predicate.
(: exists-two (All (T U) (-> (-> T U Boolean) (Vectorof T) (Vectorof U) Boolean)))
(define (exists-two predicate array-one array-two)
  (let loop ([index 0] [predicate predicate] [array-one array-one] [array-two array-two])
    (cond
      [(= index (length array-one)) #f]
      [(predicate (get array-one index) (get array-two index))]
      [else (loop (+ index 1) predicate array-one array-two)])))

; Fills a range of elements of the array with the given value.
(define (fill target target-index count value)
  (for ([index (in-range target-index count)])
    (set target index value)))

; Returns a new collection containing only the elements of the collection for which the given
; predicate returns "true".
(define (filter predicate input)
  (fold (fn (acc item) (if (predicate item) (append (vector item) acc) acc))
        (create 0 (get input 0))
        input))

; Returns the first element for which the given function returns 'true', else false.
(: find (All (T) (-> (-> T Boolean) (Vectorof T) T)))
(define (find predicate input)
  (let loop ([index 0] [predicate predicate] [input input])
    (cond
      [(= index (length input)) #f]
      [(predicate (get input index)) (get input index)]
      [else (loop (+ 1 index) predicate input)])))

; Returns the last element for which the given function returns 'true', else false.
(: find-back (All (T) (-> (-> T Boolean) (Vectorof T) T)))
(define (find-back predicate input)
  (let loop ([index (- (length input) 1)] [predicate predicate] [input input])
    (cond
      [(< index 0) #f]
      [(predicate (get input index)) (get input index)]
      [else (loop (- index 1) predicate input)])))

; Returns the index of the first element in the array that satisifes the given predicate.
; If the element doesn't exist, return false.
(: find-index (All (T) (-> (-> T integer) (Vectorof T) integer)))
(define (find-index predicate input)
  (let loop ([index 0] [predicate predicate] [input input])
    (cond
      [(= index (length input)) #f]
      [(predicate (get input index)) index]
      [else (loop (+ index 1) predicate input)])))

; Returns the index of the last element in the array that satisfies the given predicate.
; If the element doesn't exist, return false.
(: find-index-back (All (T) (-> (-> T integer) (Vectorof T) integer)))
(define (find-index-back predicate input)
  (let loop ([index (- (length input) 1)] [predicate predicate] [input input])
    (cond
      [(< index 0) #f]
      [(predicate (get input index)) index]
      [else (loop (- index 1) predicate input)])))

; Applies a function to each element of the collection, threading an accumulator
; argument through the computation. If the input function is f and the elements are
; i0..iN then computes f(...(f s i0)...) iN.
(: fold (All (T U) (-> (-> T U U) U (Vectorof T) U)))
(define (fold folder state input)
  (let loop ([index 0] [folder folder] [state state] [array input])
    (cond
      [(= index (length array)) state]
      [else (loop (+ 1 index) folder (folder state (get array index)) array)])))

; Applies a function to pairs of elements drawn from teh two collections, left-to-right,
; threading an acumlator argument through the computation. The two input array's must have the
; same length.
(define (fold-two folder state array-one array-two)
  (if (not (= (length array-one) (length array-two)))
      #f
      (let loop ([index 0] [folder folder] [state state] [array-one array-one] [array-two array-two])
        (cond
          [(= index (length array-one)) state]
          [else
           (loop (+ 1 index)
                 folder
                 (folder state (get array-one index) (get array-two index))
                 array-one
                 array-two)]))))

; Applies a function to each element of the array, starting from the end, threading
; an accumulator argument through the computation. If the input function is f and the elements
; are i0...iN then computes f i0 (...(f iN s))
(: fold-back (All (T U) (-> (-> T U U) U (Vectorof T) U)))
(define (fold-back folder state input)
  (let loop ([index (- (length input) 1)] [folder folder] [state state] [input input])
    (cond
      [(< index 0) state]
      [else (loop (- index 1) folder (folder state (get input index)) input)])))

; Apply a function to pairs of elements drawn from the two collections, right-to-left,
; threading an accumulator argument through the computation. The two input arrays must
; have the same lengths, otherwise false.
(define (fold-back-two folder state array-one array-two)
  (if (not (= (length array-one) (length array-two)))
      #f
      (let loop ([index (- (length array-one) 1)]
                 [folder folder]
                 [state state]
                 [array-one array-one]
                 [array-two array-two])
        (cond
          [(< index 0) state]
          [else
           (loop (- index 1)
                 folder
                 (folder state (get array-one index) (get array-two index))
                 array-one
                 array-two)]))))

; Tests if all elements of hte array satisfy the given predicate.
(: for-all (All (T U) (-> (-> T U U) U (Vectorof T) U)))
(define (for-all predicate array)
  (let loop ([index 0] [predicate predicate] [array array])
    (cond
      [(= index (length array)) #t]
      [(not (predicate (get array index))) #f]
      [else (loop (+ index 1) predicate array)])))

; Tests if all corresponding elements of the array satisfy the given predicate pairwise.
(: for-all-two (All (T U) (-> (-> T U U) U (Vectorof T) U)))
(define (for-all-two predicate array-one array-two)
  (let loop ([index 0] [predicate predicate] [array-one array-one] [array-two array-two])
    (cond
      [(= index (length array-one)) #t]
      [(not (predicate (get array-one index) (get array-two index))) #f]
      [else (loop (+ 1 index) predicate array-one array-two)])))


; Applies a key-generating function to each element of an array and yields an array
; of unique keys. Each unique key contains an array of all elements that match that key.
; TODO: Fix this function.
;(define (group-by projection input)
;  (~>> (fold (fn (state x)
;                 (define key (projection x))
;                 (if (Map.contains-key key state)
;                     (Map.change key (append (Map.get key state) (vector x)) state)
;                     (Map.add key (get input x) state)))
;             (Map.empty)
;             input)
;       (Map.to-array)))

(define (head input)
  (get input 0))

; Builds a new array whose elements are the corresponding elements of the input array
; paired with the integer index (from 0) of each element.
(define (indexed input)
  (let loop ([index 0] [input input])
    (cond
      [(= index (length input)) #()]
      [else (append (vector (list index (get input index))) (loop (+ 1 index) input))])))

(define (init count
              initializer)
  (for/vector ([index (in-range 0 count)])
    (initializer index)))

; TODO: This is not working.
; Return a new array with a new item inserted before the given index.
;(define (insert-at-broken index value source)
;  (define first (List.head (split-at index source)))
;  (define end (List.last (split-at index source)))
;  (vector (vector->values (vector->values first) value (vector->values end))))

; TODO: Implement.
; Return a new array with new items inserted before the given index.
(define (insert-many-at index values rouce)
  0)

; Returns true if the given array is empty, otherwise false.
(define (is-empty array)
  (= (length array) 0))

(define (iter action array)
  (for ([index (in-range 0 (length array))])
    (action (get array index))))

(define (iter-two action array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    (action (get array-one index) (get array-two index))))

(define (iter-index action array)
  (for ([index (in-range 0 (length array))])
    (action index (get array index))))

(define (iter-index-two action array-one array-two)
  (for ([index (in-range 0 (length array-one))])
    (action index (get array-one index) (get array-two index))))

(define (last array)
  (get array (- (length array) 1)))

(define (length array)
  (vector-length array))

;Builds a new array whose elements are the results of applying the given function to each of the elements to the array.
(define (map mapper input)
  (for/vector ([item input])
    (mapper item)))

; Builds a new array whose elements are the results of applying the given
; function to the corresonding elements of the two collectin pairwise.
; If the two-arrays are different lengths, return false.
(define (map-two mapper array-one array-two)
  (if (or (= 0 (length array-one)) (= 0 (length array-two)))
      #f
      (let loop ([index 0] [mapper mapper] [array-one array-one] [array-two array-two])
        (cond
          [(= index (length array-one)) #()]
          [else
           (append (vector (mapper (get array-one index) (get array-two index)))
                   (loop (+ index 1) mapper array-one array-two))]))))

; Builds a new collection whose elements are the results of applying the given function
; to the corresponding elements of the two collections pariwise. The two input
; arrays must have the same lengths else false.
(define (map-three mapper array-one array-two array-three)
  (if (or (= 0 (length array-one) (length array-two) (length array-three)))
      #f
      (let loop ([index 0]
                 [mapper mapper]
                 [array-one array-one]
                 [array-two array-two]
                 [array-three array-three])
        (cond
          [(= index (length array-one)) #()]
          [else
           (append
            (vector (mapper (get array-one index) (get array-two index) (get array-three index)))
            (loop (+ index 1) mapper array-one array-two array-three))]))))

; map-fold

; map-fold-back

; Builds a new array whose elements are the results of applying the given function to
; each of the elements of the array. The integer index passed to the function idicates the index
; of the element being transformed, starting at 0.
(define (map-i mapper input)
  (let loop ([index 0] [mapper mapper] [input input])
    (cond
      [(= index (length input)) #()]
      [(append (vector (mapper index (get input index))) (loop (+ index 1) mapper input))])))

; Builds a new collection whose elements are the results of applying the given
; function to the corresponding elements of the two collections pairwise, also passing
; the index of the elements.
(define (map-i-two mapper array-one array-two)
  (let loop ([index 0] [mapper mapper] [array-one array-one] [array-two array-two])
    (cond
      [(= index (length array-one)) #()]
      [(append (vector (mapper index (get array-one index) (get array-two index)))
               (loop (+ index 1) mapper array-one array-two))])))

; TODO: Make this to where I can figure out the value before.
; Returns the greatest of all elements of the array.
(define (max input)
  (fold (fn (state x) (if (> x state) x state)) min-int input))

; TODO: See above, need to figure out the min value before hand.
; Returns the greatest of all the elements of the array by the given projection.
(define (max-by projection input)
  (fold (fn (state x) (if (> (projection x) state) x state)) min-int input))

; TODO: See above, need to figure out the min value before hand.
; Returns the least of all the elements of the array by the given projection.
(define (min input)
  (fold (fn (state x) (if (< x state) x state)) max-int input))

; TODO: See above, need to figure out the min value before hand.
; Returns the least of all the elements of the array by the given projection.
(define (min-by projection input)
  (fold (fn (state x) (if (< (projection x) state) x state)) max-int input))

; Builds an array from the given list.
;(define (of-list input)
;  (List.to-array input))

; Returns an array of each element in the input array and it's predecessor, with the
; exception of the first element which is only returned as the predecssor of the second element.
;(define (pairwise input)
;  (let loop ([index 0] [chunk-size 2] [input input])
;    (cond
;      [(= index (- (+ (length input) 1) chunk-size)) #()]
;      [(append (vector (~>> (skip index input) (take chunk-size) (List.of-array)))
;               (loop (+ index 1) chunk-size input))])))

; Splits teh collection into two collections, containing the elements for which the given
; predicate returns true and false respectively.
(define (partition predicate input)
  0)

; Sets an element of an array.
(define (set array index value)
  (vector-set! array index value))

(define (skip size array)
  (vector-drop array size))

; Splits an array into two arrays, at the given index.
(define (split-at index input)
  (list (take index input) (~>> (skip index input) (take (- (length input) index)))))

(define (sum array)
  (fold (fn (acc item) (+ acc item)) 0 array))

;(define (sort array)
;  (vector-sort array))

(define (take size input)
  (vector-take input size)) |#

(provide (all-defined-out))

(module+ test
  (require typed/rackunit)

  (test-equal? "Append test."
               (append (Array (vector 1 2 3)) (Array (vector 4 5 6)))
               (vector 1 2 3 4 5 6)))

;(test-equal? "All-pairs works correctly."
;             (all-pairs (vector 1 2 3 4) (vector 1 2 3 4))
;             (vector '(1 1) '(2 2) '(3 3) '(4 4))))

#| (test-equal? "Append test." (append (vector 1 2 3) (vector 4 5 6)) (vector 1 2 3 4 5 6))

  (test-equal? "Average works correctly." (average (vector 2 2 4 4)) 3)

  (test-equal? "Average-by works correctly."
               (average-by (fn (x) (head x)) (vector #(2 1) #(2 1) #(4 1) #(4 1)))
               3)

  (test-equal? "Chunk-by-size works correctly."
               (chunk-by-size 2 (vector 1 2 3 4))
               (vector (vector 1 2) (vector 2 3) (vector 3 4)))

  (test-true "Contains test should resolve to true." (contains -100 (vector 1 2 3 4 100 23 -100)))

  (test-false "Contains test should resolve to false."
              (contains "blue" (vector "red" "yellow" "green")))

  (test-equal? "Copy works correctly." (copy #(1 2 3)) #(1 2 3))

  (test-equal? "Count-by works" (count-by (fn (x) x) #(1 1 1)) #((1 3)))

  (test-equal? "Count-by more complicated."
               (count-by (fn (x) x) #(1 1 1 1 3 3 3 3 2 2 2 0))
               #((0 1) (1 4) (2 3) (3 4)))

  (test-equal? "Creating an array works correctly." (create 3 0) (vector 0 0 0))

  (test-equal? "Distinct works." (distinct #(1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4)) #(1 2 3 4))

  (test-equal? "Distinct-by works."
               (distinct-by (fn (x) (string-length x)) #("one" "one" "three" "three"))
               #(3 5))

  (test-false "Exactly-one test, array has more than one." (exactly-one (vector 1 2)))

  (test-eq? "Exactly-one test, array has exactly one." (exactly-one (vector 1)) 1)

  (test-true "Exists test, 1 is in the array." (exists (fn (item) (= item 1)) (vector 1 2 3 4)))

  (test-false "Exists test, blue is not in the array."
              (exists (fn (item) (equal? item "blue")) (vector "red" "yellow" "green")))

  (test-false "Exists returns false, empty array." (exists (fn (x) (= x 1)) #()))

  (test-true "Exists returns true, one element." (exists (fn (x) (= x 1)) #(1)))

  (test-true "Exists-two works correctly." (exists-two (fn (x y) (= x y)) #(1 2 3 4) #(2 3 6 4)))

  (test-case "Fill works correctly."
    (define filled (vector 1 2 3 4))
    (fill filled 1 2 3)
    (check-equal? filled #(1 3 3 4)))

  (test-equal? "Find works and finds the value." (find (fn (x) (= x 1)) (vector 4 3 2 1)) 1)

  (test-false "Find works and returns false because it doesn't have the element."
              (find (fn (x) (= x 1)) (vector 4 4 4 4)))

  (test-equal? "Find-back works and finds the value." (find-back (fn (x) (= x 1)) (vector 1 2 3 4)) 1)

  (test-false "Find-back works and returns false because the element isn't found."
              (find-back (fn (x) (= x 1)) (vector 4 4 4 4)))

  (test-equal? "Find-index works." (find-index (fn (x) (= x 1)) (vector 4 2 1 3)) 2)

  (test-false "Find-index returns false because the element doesn't exist."
              (find-index (fn (x) (= x 1)) (vector 4 4 4 4)))

  (test-equal? "Find-index-back works." (find-index-back (fn (x) (= x 2)) (vector 1 2 3 4)) 1)

  (test-false "Find-index-back returns false because the element doesn't exist."
              (find-index-back (fn (x) (= x 1)) (vector 4 4 4 4)))

  (test-eq? "Fold test, array should add up to 10."
            (fold (fn (acc item) (+ acc item)) 0 (vector 1 2 3 4))
            10)

  (test-eq? "Fold-two test, arrays should add up to 20"
            (fold-two (fn (acc item-one item-two) (+ acc item-one item-two))
                      0
                      (vector 1 2 3 4)
                      (vector 1 2 3 4))
            20)

  (test-false "Fold-two-test false, two arrays are different lengths."
              (fold-two (fn (acc item-one item-two) (+ acc item-one item-two))
                        0
                        (vector 1 2 3)
                        (vector 1 2 3 4)))

  (test-equal? "Fold back works correctly."
               (fold-back (fn (acc item) (- item acc)) 1 (vector 1 2 3))
               1)

  (test-false "Fold-two-back-test false, two arrays are different lengths."
              (fold-back-two (fn (acc item-one item-two) (+ acc item-one item-two))
                             0
                             (vector 1 2 3)
                             (vector 1 2 3 4)))

  (test-eq? "Fold-two test, arrays should add up to 20"
            (fold-back-two (fn (acc item-one item-two) (+ acc item-one item-two))
                           0
                           (vector 1 2 3 4)
                           (vector 1 2 3 4))
            20)

  (test-equal? "Filter takes any item equal to one."
               (filter (fn (item) (= item 1)) (vector 1 1 1 2 2 2))
               (vector 1 1 1))

  (test-equal? "Filter takes any string length that is greater than 3"
               (filter (fn (item) (> (string-length item) 3)) (vector "one" "two" "three"))
               (vector "three"))

  (test-true "For-all returns true, the item in the vector is greater than 2."
             (for-all (fn (item) (> item 2)) (vector 3 4 5 6 7)))

  (test-false "For-all returns false because no items match."
              (for-all (fn (item) (> item 2)) (vector 1 2 3 4 5)))

  (test-true "For-all-two returns true."
             (for-all-two (fn (x y) (= (+ x y) 5)) (vector 2 2 2 2 2) (vector 3 3 3 3 3)))

  (test-false "For-all-two returns false."
              (for-all-two (fn (x y) (> x y)) (vector 1 2 3) (vector 3 4 5)))

  (test-eq? "Getting the first element returns 1." (get (vector 1 2 3 4) 0) 1)

  #| (test-case "Group-by works."
    (define start-array
      (vector '("john" 23) '("john" 18) '("tim" 5) '("henry" 22) '("henry" 57) '("henry" 100)))
    (define (names tuple)
      (List.head tuple))
    (define target-array
      (vector '("john" (vector 23 18)) '("tim" (vector 5)) '("henry" (vector 22 57 100))))
    (check-equal? (group-by names start-array) target-array)) |#

  (test-equal? "Indexed works correctly." (indexed #(1 2 3 4)) #((0 1) (1 2) (2 3) (3 4)))

  (test-equal? "Map-two works correctly."
               (map-two (fn (x y) (+ x y)) #(1 2 3 4) #(1 2 3 4))
               #(2 4 6 8))

  (test-equal? "Map-three works correctly."
               (map-three (fn (x y z) (+ x y z)) #(1 2 3 4) #(1 2 3 4) #(1 2 3 4))
               #(3 6 9 12))

  ;(test-equal? "Insert-at works." (insert-at 1 23 (vector 1 2 3 4)) (vector 1 23 2 3 4))

  (test-equal? "Mapping over an array works correctly, simple addition."
               (map (fn (item) (add1 item)) (vector 1 2 3 4))
               (vector 2 3 4 5))

  (test-equal? "Mapping over an array works correctly, length of strings."
               (map (fn (item) (string-length item)) (vector "one" "two" "three"))
               (vector 3 3 5))

  (test-equal? "Map-i works." (map-i (fn (x y) (+ x y)) (vector 1 2 3 4)) #(1 3 5 7))

  (test-equal? "Map-i-two works."
               (map-i-two (fn (x y z) (+ x y z)) (vector 1 2 3 4) (vector 1 2 3 4))
               #(2 5 8 11))

  (test-eq? "Max works." (max (vector 4 2 3 1)) 4)

  (test-eq? "Max-by works." (max-by (fn (x) x) (vector 4 2 3 1)) 4)

  (test-eq? "Min works." (min (vector 1 3 2 4)) 1)

  (test-eq? "Min-by works." (min-by (fn (x) x) (vector 1 3 2 4)) 1)

  (test-equal? "Of-list works." (of-list (list 1 2 3 4)) #(1 2 3 4))

  (test-equal? "Pairwise works." (pairwise (vector 1 2 3 4)) #((1 2) (2 3) (3 4)))

  (test-equal? "Initializing an array works correctly."
               (init 3
                     (fn (item) (add1 item)))
               (vector 1 2 3))

  (test-true "The array is empty." (is-empty (vector)))

  (test-false "The array is not empty." (is-empty (vector 1)))

  (test-eq? "The last item in the array is 4." (last (vector 1 2 3 4)) 4)

  (test-equal? "Split-at works correctly." (split-at 2 (vector 1 2 3 4 5)) (list #(1 2) #(3 4 5)))

  (test-equal? "Split-at complicated." (split-at 1 (vector 1 2 3 4 5)) (list #(1) #(2 3 4 5)))

  (test-equal? "Split-at at the end." (split-at 4 (vector 1 2 3 4 5)) (list #(1 2 3 4) #(5))) |#
